From b01ffebd7597dabf3dd268bf938ff1a905f7e221 Mon Sep 17 00:00:00 2001
From: Todor Minchev <todor@minchev.co.uk>
Date: Fri, 13 Feb 2015 21:34:53 +0000
Subject: [PATCH 12/16] staging:iio: add support for ADCs and hrtimer triger

Galileo Gen1 - AD7298 ADC
Galileo Gen2 - ADC1x8s102

Signed-off-by: Todor Minchev <todor@minchev.co.uk>
---
 .config                                        |   2 +
 drivers/iio/adc/ad7298.c                       |  17 +-
 drivers/staging/iio/adc/Kconfig                |  13 +
 drivers/staging/iio/adc/Makefile               |   1 +
 drivers/staging/iio/adc/adc1x8s102.c           | 387 +++++++++++++++++++++++++
 drivers/staging/iio/trigger/Kconfig            |  11 +
 drivers/staging/iio/trigger/Makefile           |   1 +
 drivers/staging/iio/trigger/iio-trig-hrtimer.c | 288 ++++++++++++++++++
 8 files changed, 716 insertions(+), 4 deletions(-)
 create mode 100644 drivers/staging/iio/adc/adc1x8s102.c
 create mode 100644 drivers/staging/iio/trigger/iio-trig-hrtimer.c

diff --git a/.config b/.config
index dab1581..a80a302 100644
--- a/.config
+++ b/.config
@@ -2934,6 +2934,7 @@ CONFIG_STAGING=y
 # CONFIG_AD7816 is not set
 # CONFIG_AD7192 is not set
 # CONFIG_AD7280 is not set
+CONFIG_ADC1x8S102=m
 
 #
 # Analog digital bi-direction converters
@@ -2997,6 +2998,7 @@ CONFIG_STAGING=y
 # Triggers - standalone
 #
 # CONFIG_IIO_PERIODIC_RTC_TRIGGER is not set
+CONFIG_IIO_HRTIMER_TRIGGER=m
 # CONFIG_IIO_SIMPLE_DUMMY is not set
 # CONFIG_FT1000 is not set
 
diff --git a/drivers/iio/adc/ad7298.c b/drivers/iio/adc/ad7298.c
index 4a8c0a2..69663da 100644
--- a/drivers/iio/adc/ad7298.c
+++ b/drivers/iio/adc/ad7298.c
@@ -34,7 +34,6 @@
 #define AD7298_TAVG	BIT(1) /* temperature sensor averaging enable */
 #define AD7298_PDD	BIT(0) /* partial power down enable */
 
-#define AD7298_MAX_CHAN		8
 #define AD7298_INTREF_mV	2500
 
 #define AD7298_CH_TEMP		9
@@ -43,6 +42,7 @@ struct ad7298_state {
 	struct spi_device		*spi;
 	struct regulator		*reg;
 	unsigned			ext_ref;
+	u16						ext_vin_max[AD7298_MAX_CHAN];
 	struct spi_transfer		ring_xfer[10];
 	struct spi_transfer		scan_single_xfer[3];
 	struct spi_message		ring_msg;
@@ -260,7 +260,10 @@ static int ad7298_read_raw(struct iio_dev *indio_dev,
 	case IIO_CHAN_INFO_SCALE:
 		switch (chan->type) {
 		case IIO_VOLTAGE:
-			*val = ad7298_get_ref_voltage(st);
+			if (st->ext_vin_max[chan->channel])
+				*val = st->ext_vin_max[chan->channel];
+			else
+				*val = ad7298_get_ref_voltage(st);
 			*val2 = chan->scan_type.realbits;
 			return IIO_VAL_FRACTIONAL_LOG2;
 		case IIO_TEMP:
@@ -296,8 +299,14 @@ static int ad7298_probe(struct spi_device *spi)
 
 	st = iio_priv(indio_dev);
 
-	if (pdata && pdata->ext_ref)
-		st->ext_ref = AD7298_EXTREF;
+	if (pdata) {
+		int i;
+		if (pdata->ext_ref)
+			st->ext_ref = AD7298_EXTREF;
+
+		for (i = 0; i < AD7298_MAX_CHAN; i++)
+			st->ext_vin_max[i] = pdata->ext_vin_max[i];
+	}
 
 	if (st->ext_ref) {
 		st->reg = devm_regulator_get(&spi->dev, "vref");
diff --git a/drivers/staging/iio/adc/Kconfig b/drivers/staging/iio/adc/Kconfig
index d0016ce..7d295a6 100644
--- a/drivers/staging/iio/adc/Kconfig
+++ b/drivers/staging/iio/adc/Kconfig
@@ -115,4 +115,17 @@ config SPEAR_ADC
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called spear_adc.
+
+config ADC1x8S102
+	tristate "Texas Instruments ADC1x8S102 driver"
+	depends on SPI
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	help
+		Say yes here to build support for Texas Instruments ADC1x8S102 ADC.
+		Provides direct access via sysfs.
+
+		To compile this driver as a module, choose M here: the module will
+		be called adc1x8s102
+
 endmenu
diff --git a/drivers/staging/iio/adc/Makefile b/drivers/staging/iio/adc/Makefile
index 1c4277d..3fe3880 100644
--- a/drivers/staging/iio/adc/Makefile
+++ b/drivers/staging/iio/adc/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_AD7280) += ad7280a.o
 obj-$(CONFIG_LPC32XX_ADC) += lpc32xx_adc.o
 obj-$(CONFIG_MXS_LRADC) += mxs-lradc.o
 obj-$(CONFIG_SPEAR_ADC) += spear_adc.o
+obj-$(CONFIG_ADC1x8S102) += adc1x8s102.o
diff --git a/drivers/staging/iio/adc/adc1x8s102.c b/drivers/staging/iio/adc/adc1x8s102.c
new file mode 100644
index 0000000..52472e2
--- /dev/null
+++ b/drivers/staging/iio/adc/adc1x8s102.c
@@ -0,0 +1,387 @@
+/*
+ * ADC1x8S102 SPI ADC driver
+ *
+ * Copyright(c) 2013 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * This IIO device driver is is designed to work with the following
+ * analog to digital converters from Texas Instruments:
+ *  ADC108S102
+ *  ADC128S102
+ * The communication with ADC chip is via the SPI bus (mode 3).
+ */
+
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/types.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+
+#include <linux/platform_data/adc1x8s102.h>
+#include <linux/regulator/consumer.h>
+
+/*
+ * Defining the ADC resolution being 12 bits, we can use the same driver for
+ * both ADC108S102 (10 bits resolution) and ADC128S102 (12 bits resolution)
+ * chips. The ADC108S102 effectively returns a 12-bit result with the 2
+ * least-significant bits unset.
+ */
+#define ADC1x8S102_BITS		12
+#define ADC1x8S102_MAX_CHANNELS	8
+
+/* 16-bit SPI command format:
+ *   [15:14] Ignored
+ *   [13:11] 3-bit channel address
+ *   [10:0]  Ignored
+ */
+#define ADC1x8S102_CMD(ch)		(((ch) << (8)) << (3))
+
+/*
+ * 16-bit SPI response format:
+ *   [15:12] Zeros
+ *   [11:0]  12-bit ADC sample (for ADC108S102, [1:0] will always be 0).
+ */
+#define ADC1x8S102_RES_DATA(res)	(res & ((1 << ADC1x8S102_BITS) - 1))
+
+struct adc1x8s102_state {
+	struct spi_device		*spi;
+	struct regulator		*reg;
+	u16				ext_vin;
+	/* SPI transfer used by triggered buffer handler*/
+	struct spi_transfer		ring_xfer;
+	/* SPI transfer used by direct scan */
+	struct spi_transfer		scan_single_xfer;
+	/* SPI message used by ring_xfer SPI transfer */
+	struct spi_message		ring_msg;
+	/* SPI message used by scan_single_xfer SPI transfer */
+	struct spi_message		scan_single_msg;
+
+	/* SPI message buffers:
+	 *  tx_buf: |C0|C1|C2|C3|C4|C5|C6|C7|XX|
+	 *  rx_buf: |XX|R0|R1|R2|R3|R4|R5|R6|R7|tt|tt|tt|tt|
+	 *
+	 *  tx_buf: 8 channel read commands, plus 1 dummy command
+	 *  rx_buf: 1 dummy response, 8 channel responses, plus 64-bit timestamp
+	 */
+	__be16				rx_buf[13] ____cacheline_aligned;
+	__be16				tx_buf[9];
+
+};
+
+#define ADC1X8S102_V_CHAN(index)					\
+	{								\
+		.type = IIO_VOLTAGE,					\
+		.indexed = 1,						\
+		.channel = index,					\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+			BIT(IIO_CHAN_INFO_SCALE),		\
+		.address = index,					\
+		.scan_index = index,					\
+		.scan_type = {						\
+			.sign = 'u',					\
+			.realbits = ADC1x8S102_BITS,			\
+			.storagebits = 16,				\
+			.endianness = IIO_BE,				\
+		},							\
+	}
+
+static const struct iio_chan_spec adc1x8s102_channels[] = {
+	ADC1X8S102_V_CHAN(0),
+	ADC1X8S102_V_CHAN(1),
+	ADC1X8S102_V_CHAN(2),
+	ADC1X8S102_V_CHAN(3),
+	ADC1X8S102_V_CHAN(4),
+	ADC1X8S102_V_CHAN(5),
+	ADC1X8S102_V_CHAN(6),
+	ADC1X8S102_V_CHAN(7),
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+};
+
+
+static int adc1x8s102_update_scan_mode(struct iio_dev *indio_dev,
+		unsigned long const *active_scan_mask)
+{
+	struct adc1x8s102_state *st;
+	int i, j;
+
+	st = iio_priv(indio_dev);
+
+	/* Fill in the first x shorts of tx_buf with the number of channels
+	 * enabled for sampling by the triggered buffer
+	 */
+	for (i = 0, j = 0; i < ADC1x8S102_MAX_CHANNELS; i++) {
+		if (test_bit(i, active_scan_mask)) {
+			st->tx_buf[j] = cpu_to_be16(ADC1x8S102_CMD(i));
+			j++;
+		}
+	}
+	/* One dummy command added, to clock in the last response */
+	st->tx_buf[j] = 0x00;
+
+	/* build SPI ring message */
+	st->ring_xfer.tx_buf = &st->tx_buf[0];
+	st->ring_xfer.rx_buf = &st->rx_buf[0];
+	st->ring_xfer.len = (j + 1) * sizeof(__be16);
+
+	spi_message_init(&st->ring_msg);
+	spi_message_add_tail(&st->ring_xfer, &st->ring_msg);
+
+	return 0;
+}
+
+
+static irqreturn_t adc1x8s102_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev;
+	struct adc1x8s102_state *st;
+	s64 time_ns = 0;
+	int b_sent;
+
+	indio_dev = pf->indio_dev;
+	st = iio_priv(indio_dev);
+
+	b_sent = spi_sync(st->spi, &st->ring_msg);
+	if (b_sent)
+		goto done;
+	if (indio_dev->scan_timestamp) {
+		time_ns = iio_get_time_ns();
+		memcpy((u8 *)st->rx_buf + st->ring_xfer.len, &time_ns,
+				sizeof(time_ns));
+	}
+
+	/* Skip the dummy response in the first slot */
+	iio_push_to_buffers(indio_dev, (u8 *)&st->rx_buf[1]);
+done:
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * returns:
+ * positive (>=0)  value => SUCCESS
+ * negative value => FAILURE
+ */
+static int adc1x8s102_scan_direct(struct adc1x8s102_state *st, unsigned ch)
+{
+	int ret;
+
+	if (ch >= ADC1x8S102_MAX_CHANNELS) {
+		dev_err(&st->spi->dev, "AD channel number too big: %u\n", ch);
+		return -1;
+	}
+
+	st->tx_buf[0] = cpu_to_be16(ADC1x8S102_CMD(ch));
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret)
+		return ret;
+
+	/* Skip the dummy response in the first slot */
+	return be16_to_cpu(st->rx_buf[1]);
+}
+
+
+/*
+ * returns:
+ * positive (>=0)  value => SUCCESS
+ * negative value => FAILURE
+ */
+static int adc1x8s102_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	int ret;
+	struct adc1x8s102_state *st;
+
+	st = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED) {
+			ret = -EBUSY;
+			dev_warn(&st->spi->dev,
+			 "indio_dev->currentmode is INDIO_BUFFER_TRIGGERED\n");
+		} else {
+			ret = adc1x8s102_scan_direct(st, chan->address);
+		}
+		mutex_unlock(&indio_dev->mlock);
+
+		if (ret < 0)
+			return ret;
+		*val = ADC1x8S102_RES_DATA(ret);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_VOLTAGE:
+			if (NULL != st->reg)
+				*val = regulator_get_voltage(st->reg) / 1000;
+			else
+				*val = st->ext_vin;
+
+			*val2 = chan->scan_type.realbits;
+			return IIO_VAL_FRACTIONAL_LOG2;
+		default:
+			dev_warn(&st->spi->dev,
+				 "Invalid channel type %u for channel %d\n",
+				 chan->type, chan->channel);
+			return -EINVAL;
+		}
+	default:
+		dev_warn(&st->spi->dev, "Invalid IIO_CHAN_INFO: %lu\n", m);
+		return -EINVAL;
+	}
+}
+
+
+
+static const struct iio_info adc1x8s102_info = {
+	.read_raw		= &adc1x8s102_read_raw,
+	.update_scan_mode	= &adc1x8s102_update_scan_mode,
+	.driver_module		= THIS_MODULE,
+};
+
+
+static int adc1x8s102_probe(struct spi_device *spi)
+{
+	struct adc1x8s102_platform_data *pdata = spi->dev.platform_data;
+	struct adc1x8s102_state *st;
+	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
+	int ret;
+
+	if (NULL == indio_dev) {
+		dev_crit(&spi->dev, "Cannot allocate memory for indio_dev\n");
+		return -ENOMEM;
+	}
+
+	st = iio_priv(indio_dev);
+	if (NULL == pdata) {
+		dev_err(&spi->dev, "Cannot get adc1x8s102 platform data\n");
+		return -EFAULT;
+	}
+	st->ext_vin = pdata->ext_vin;
+
+	/* Use regulator, if available. */
+	st->reg = regulator_get(&spi->dev, "vref");
+	if (IS_ERR(st->reg)) {
+		ret = PTR_ERR(st->reg);
+		dev_warn(&spi->dev,
+			 "Cannot get 'vref' regulator\n");
+		goto error_free;
+	}
+	ret = regulator_enable(st->reg);
+	if (ret < 0) {
+		dev_warn(&spi->dev,
+			 "Cannot enable vref regulator\n");
+		goto error_put_reg;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+	st->spi = spi;
+
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = adc1x8s102_channels;
+	indio_dev->num_channels = ARRAY_SIZE(adc1x8s102_channels);
+	indio_dev->info = &adc1x8s102_info;
+
+	/* Setup default message */
+	st->scan_single_xfer.tx_buf = st->tx_buf;
+	st->scan_single_xfer.rx_buf = st->rx_buf;
+	st->scan_single_xfer.len = 2 * sizeof(__be16);
+	st->scan_single_xfer.cs_change = 0;
+
+	spi_message_init(&st->scan_single_msg);
+	spi_message_add_tail(&st->scan_single_xfer, &st->scan_single_msg);
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+			&adc1x8s102_trigger_handler, NULL);
+	if (ret)
+		goto error_disable_reg;
+
+	ret = iio_device_register(indio_dev);
+	if (ret) {
+		dev_err(&spi->dev,
+			"Failed to register IIO device\n");
+		goto error_cleanup_ring;
+	}
+	return 0;
+
+error_cleanup_ring:
+	iio_triggered_buffer_cleanup(indio_dev);
+error_disable_reg:
+	regulator_disable(st->reg);
+error_put_reg:
+	regulator_put(st->reg);
+error_free:
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+
+static int adc1x8s102_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev;
+	struct adc1x8s102_state *st;
+
+	indio_dev = spi_get_drvdata(spi);
+	if (NULL == indio_dev) {
+		dev_err(&spi->dev, "Cannot get spi_device drvdata\n");
+		return -EFAULT;
+	}
+
+	st = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+
+	iio_triggered_buffer_cleanup(indio_dev);
+
+	regulator_disable(st->reg);
+	regulator_put(st->reg);
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+
+static const struct spi_device_id adc1x8s102_id[] = {
+	{"adc1x8s102", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(spi, adc1x8s102_id);
+
+static struct spi_driver adc1x8s102_driver = {
+	.driver = {
+		.name	= "adc1x8s102",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= adc1x8s102_probe,
+	.remove		= adc1x8s102_remove,
+	.id_table	= adc1x8s102_id,
+};
+module_spi_driver(adc1x8s102_driver);
+
+MODULE_AUTHOR("Bogdan Pricop <bogdan.pricop@emutex.com>");
+MODULE_DESCRIPTION("Texas Instruments ADC1x8S102 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/staging/iio/trigger/Kconfig b/drivers/staging/iio/trigger/Kconfig
index 710a2f3..a6688cc 100644
--- a/drivers/staging/iio/trigger/Kconfig
+++ b/drivers/staging/iio/trigger/Kconfig
@@ -26,4 +26,15 @@ config IIO_BFIN_TMR_TRIGGER
 	  To compile this driver as a module, choose M here: the
 	  module will be called iio-trig-bfin-timer.
 
+config IIO_HRTIMER_TRIGGER
+	tristate "HRTIMER trigger"
+	#depends on HRTIMER
+	select IRQ_WORK
+	help
+		Provides support for using HRTIMER entries as IIO triggers.
+		If unsure, say N (but it's safe to say "Y").
+
+		To compile this driver as a module, choose M here: the
+		module will be called iio-trig-hrtimer.
+
 endif # IIO_TRIGGER
diff --git a/drivers/staging/iio/trigger/Makefile b/drivers/staging/iio/trigger/Makefile
index 238481b..1084b0f 100644
--- a/drivers/staging/iio/trigger/Makefile
+++ b/drivers/staging/iio/trigger/Makefile
@@ -4,3 +4,4 @@
 
 obj-$(CONFIG_IIO_PERIODIC_RTC_TRIGGER) += iio-trig-periodic-rtc.o
 obj-$(CONFIG_IIO_BFIN_TMR_TRIGGER) += iio-trig-bfin-timer.o
+obj-$(CONFIG_IIO_HRTIMER_TRIGGER) += iio-trig-hrtimer.o
diff --git a/drivers/staging/iio/trigger/iio-trig-hrtimer.c b/drivers/staging/iio/trigger/iio-trig-hrtimer.c
new file mode 100644
index 0000000..e111ab7
--- /dev/null
+++ b/drivers/staging/iio/trigger/iio-trig-hrtimer.c
@@ -0,0 +1,288 @@
+/*
+ * Industrial I/O - hrtimer trigger support
+ *
+ * Copyright 2013 STMicroelectronics Inc.
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+struct iio_hrtimer_trigger_data {
+	struct iio_trigger *trig;
+	struct hrtimer timer;
+	struct list_head l;
+	ktime_t period;
+	u16  freq;
+	int id;
+};
+
+static LIST_HEAD(iio_hrtimer_trigger_list);
+static DEFINE_MUTEX(iio_hrtimer_trigger_list_mut);
+
+static int iio_hrtimer_trigger_probe(int id);
+static int iio_hrtimer_trigger_remove(int id);
+
+static ssize_t iio_sysfs_hrtimer_trig_add(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = kstrtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+
+	ret = iio_hrtimer_trigger_probe(input);
+	if (ret)
+		return ret;
+
+	return len;
+}
+static DEVICE_ATTR(add_trigger, S_IWUSR, NULL, &iio_sysfs_hrtimer_trig_add);
+
+static ssize_t iio_sysfs_hrtimer_trig_remove(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	unsigned long input;
+
+	ret = kstrtoul(buf, 10, &input);
+	if (ret)
+		return ret;
+
+	ret = iio_hrtimer_trigger_remove(input);
+	if (ret)
+		return ret;
+
+	return len;
+}
+static DEVICE_ATTR(remove_trigger, S_IWUSR,
+					NULL, &iio_sysfs_hrtimer_trig_remove);
+
+static struct attribute *iio_hrtimer_trig_attrs[] = {
+	&dev_attr_add_trigger.attr,
+	&dev_attr_remove_trigger.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_hrtimer_trig_group = {
+	.attrs = iio_hrtimer_trig_attrs,
+};
+
+static const struct attribute_group *iio_hrtimer_trig_groups[] = {
+	&iio_hrtimer_trig_group,
+	NULL,
+};
+
+/* Nothing to actually do upon release */
+static void iio_hrtimer_trig_release(struct device *dev)
+{
+}
+
+static struct device iio_hrtimer_trig_dev = {
+	.bus = &iio_bus_type,
+	.groups = iio_hrtimer_trig_groups,
+	.release = &iio_hrtimer_trig_release,
+};
+
+static int iio_hrtimer_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	if (trig_data->freq == 0)
+		return -EINVAL;
+
+	if (state)
+		hrtimer_start(&trig_data->timer,
+					trig_data->period, HRTIMER_MODE_REL);
+	else
+		hrtimer_cancel(&trig_data->timer);
+
+	return 0;
+}
+
+static ssize_t iio_hrtimer_trigger_set_freq_value(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret;
+	u16 frequency;
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	ret = kstrtou16(buf, 10, &frequency);
+	if (ret < 0)
+		return ret;
+
+	if (frequency > NSEC_PER_SEC)
+		return -EINVAL;
+
+	trig_data->freq = frequency;
+
+	if (frequency)
+		trig_data->period =
+				ktime_set(0, NSEC_PER_SEC / trig_data->freq);
+
+	return len;
+}
+
+static ssize_t iio_hrtimer_trigger_get_freq_value(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct iio_trigger *trig = to_iio_trigger(dev);
+	struct iio_hrtimer_trigger_data *trig_data =
+						dev_get_drvdata(&trig->dev);
+
+	return sprintf(buf, "%hu\n", trig_data->freq);
+}
+
+static DEVICE_ATTR(frequency, S_IWUSR | S_IRUGO,
+					iio_hrtimer_trigger_get_freq_value,
+					iio_hrtimer_trigger_set_freq_value);
+
+static struct attribute *iio_hrtimer_trigger_attrs[] = {
+	&dev_attr_frequency.attr,
+	NULL,
+};
+
+static const struct attribute_group iio_hrtimer_trigger_attr_group = {
+	.attrs = iio_hrtimer_trigger_attrs,
+};
+
+static const struct attribute_group *iio_hrtimer_trigger_attr_groups[] = {
+	&iio_hrtimer_trigger_attr_group,
+	NULL,
+};
+
+static const struct iio_trigger_ops iio_hrtimer_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = &iio_hrtimer_trig_set_state,
+};
+
+enum hrtimer_restart iio_hrtimer_trigger_func(struct hrtimer *timer)
+{
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	trig_data = container_of(timer, struct iio_hrtimer_trigger_data, timer);
+
+	hrtimer_forward_now(timer, trig_data->period);
+	iio_trigger_poll(trig_data->trig);
+
+	return HRTIMER_RESTART;
+}
+
+static int iio_hrtimer_trigger_probe(int id)
+{
+	int err;
+	bool foundit = false;
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	mutex_lock(&iio_hrtimer_trigger_list_mut);
+	list_for_each_entry(trig_data, &iio_hrtimer_trigger_list, l) {
+		if (id == trig_data->id) {
+			foundit = true;
+			break;
+		}
+	}
+	if (foundit) {
+		err = -EINVAL;
+		goto iio_hrtimer_mutex_unlock;
+	}
+
+	trig_data = kmalloc(sizeof(*trig_data), GFP_KERNEL);
+	if (trig_data == NULL) {
+		err = -ENOMEM;
+		goto iio_hrtimer_mutex_unlock;
+	}
+
+	trig_data->id = id;
+	trig_data->trig = iio_trigger_alloc("hrtimer_trig%d", id);
+	if (!trig_data->trig) {
+		err = -ENOMEM;
+		goto iio_hrtimer_free_trig_data;
+	}
+
+	trig_data->trig->dev.groups = iio_hrtimer_trigger_attr_groups;
+	trig_data->trig->ops = &iio_hrtimer_trigger_ops;
+	trig_data->trig->dev.parent = &iio_hrtimer_trig_dev;
+	dev_set_drvdata(&trig_data->trig->dev, trig_data);
+
+	trig_data->freq = 0;
+	hrtimer_init(&trig_data->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	trig_data->timer.function = &iio_hrtimer_trigger_func;
+
+	err = iio_trigger_register(trig_data->trig);
+	if (err)
+		goto iio_hrtimer_free_trig_data;
+
+	list_add(&trig_data->l, &iio_hrtimer_trigger_list);
+	__module_get(THIS_MODULE);
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+
+	return 0;
+
+iio_hrtimer_free_trig_data:
+	kfree(trig_data);
+iio_hrtimer_mutex_unlock:
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+	return err;
+}
+
+static int iio_hrtimer_trigger_remove(int id)
+{
+	bool foundit = false;
+	struct iio_hrtimer_trigger_data *trig_data;
+
+	mutex_lock(&iio_hrtimer_trigger_list_mut);
+	list_for_each_entry(trig_data, &iio_hrtimer_trigger_list, l) {
+		if (id == trig_data->id) {
+			foundit = true;
+			break;
+		}
+	}
+	if (!foundit) {
+		mutex_unlock(&iio_hrtimer_trigger_list_mut);
+		return -EINVAL;
+	}
+
+	iio_trigger_unregister(trig_data->trig);
+	iio_trigger_free(trig_data->trig);
+
+	list_del(&trig_data->l);
+	kfree(trig_data);
+	module_put(THIS_MODULE);
+	mutex_unlock(&iio_hrtimer_trigger_list_mut);
+
+	return 0;
+}
+
+static int __init iio_hrtimer_trig_init(void)
+{
+	device_initialize(&iio_hrtimer_trig_dev);
+	dev_set_name(&iio_hrtimer_trig_dev, "iio_hrtimer_trigger");
+	return device_add(&iio_hrtimer_trig_dev);
+}
+module_init(iio_hrtimer_trig_init);
+
+static void __exit iio_hrtimer_trig_exit(void)
+{
+	device_unregister(&iio_hrtimer_trig_dev);
+}
+module_exit(iio_hrtimer_trig_exit);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("Hrtimer trigger for the iio subsystem");
+MODULE_LICENSE("GPL v2");
-- 
1.9.1

